# 数组与指针

数组与指针常常出现许多神奇的使用方法，和可能遇到的容易踩坑的点

## 数组名与指针

在申请一个数组时，其内存空间被分为了两部分

* 数组名被存放在了常量内存区，是不可修改的
* 数组元素是存放在可变内存区，是可以修改的

```c
char str[3] = {'a', 'b', 'c'};
printf("str = %p str[0] = %p str[1] = %p str[2] = %p", &str, &str[0], &str[1], &str[2]);
/**
 * 输出结果：
 * str = 0x7ffe1b1a6ea5 str[0] = 0x7ffe1b1a6ea5 str[1] = 0x7ffe1b1a6ea6 str[2] = 0x7ffe1b1a6ea7
 */


char str[3] = {'a', 'b', 'c'};
printf("str = %p str[0] = %p str[1] = %p str[2] = %p", str, str[0], str[1], str[2]);
/**
 * 多次运行后输出结果：
 * str = 0x7ffd2afb3055 str[0] = 0x61 str[1] = 0x62 str[2] = 0x63
 * str = 0x7fff4e277f15 str[0] = 0x61 str[1] = 0x62 str[2] = 0x63
 * str = 0x7ffdd057c805 str[0] = 0x61 str[1] = 0x62 str[2] = 0x63
 * str = 0x7ffcc01f0fe5 str[0] = 0x61 str[1] = 0x62 str[2] = 0x63
 * str = 0x7ffcbe2cce35 str[0] = 0x61 str[1] = 0x62 str[2] = 0x63
 */
```

从第一段代码可以看到，数组名和数组`0`号元素**所在的内存地址**是相同的，并且和数组其他元素的**所在的内存是连续的**；从第二段代码可以看到，数组名**指向的地址**是每次重新分配的且在常量内存区是**不可更改的**，数组的`0`元素指向的地址则是指向数组的首个元素

由于这个特性，数组名与指针并不能完全视作等价



## char数组与char*指针

在`C`语言中操作字符串通常是创建一个`char`数组或者一个`char*`指针指向某个字符串。是直接操作内存，常常引发一些内存安全问题。以下是一些使用时的注意事项

* 通常会将`char`数组的名字视为一个`char*`指针，但这两者并不严格相等

    * 数组名指向的内存不可更改，指针指向的内存可更改。但二者都不可更改其本身的内存地址

    * 在`struct`声明时，有时会在`struct`尾部加上一行`char[0]`，这种写法是考虑到结构体内存对齐默认按照最长元素来对齐。当不适合在声明时创建大数组可以后续申请内存时可以灵活的确定申请内存的长度，实现变长申请内存。例如消息信息等内容，结构体申请时需要一个变长的字符串。

        ```c
        struct struct_A {
            int a;
            char b[1];			//char[1]会占用一个字节的内存
        }__attribute ((packed));
        
        /* 
         * 如果分配的内存大于结构体的实际大小，那么超出的那部分就是b的内容。
         */
        struct struct_B {
            int a;
            char b[0];			//charb[0]实际不占用的内存，只是一个地址偏移量
        }__attribute ((packed));
        
        int main()
        {
            struct struct_A A;
            struct struct_B B;
        
            int a = sizeof(A);
            printf("%d \n", a);		//输出：5
        
            int b = sizeof(B);
            printf("%d \n", b);		//输出：4
            
            struct struct_B *C;
            C = (struct struct_B *)malloc(sizeof(struct struct_B) + 10);
        
            strcpy(C->b, "abcde");
            printf("%s \n", C->b);	//输出：abcde
        
            return 0;
        }
        ```

* 将`C`语言转换成汇编后可以发现，`[]`运算符其本质是取地址偏移量，这与指针运算相同

    * **指针运算与使用`[]`和数组下标取元素，其汇编只是近似，但不严格相同**

