# EffectiveC++读书笔记

[TOC]

## 条款1：**视`C++`为一个语言联邦**

`C++`是一种多重范型编程语言,同时可以支持以下的几种编程范式

* **过程形式**`procedural`
* **面向对象形式**`object-oriented`
* **函数形式**`functional`
* **泛型形式**`generic`
* **元编程形式**`metaprogramming`8

为了更好的理解`C++`的这几种编程范式，我们可以将`C++`视作是由几种相关的编程语言组成的语言联邦，每个子语言都遵循了一定的守则与通例

1. **C语言：**说到底`C++`仍是以`C`为基础。区块`blocks`、语句`statements`、预处理器`preprocessor`、内置数据类型`built-in data types`、数组`arrays`、指针`pointers`等统统来自`C`。许多时候`C++`对问题的解法其实不过就是较高级的`C`解法，但当你以`C++`内的`C`成分工作时，高效编程守则映照出`C`语言的局限：没有模板`templates`,没有异常`exceptions`,没有重载`overloading`等等
2. **Object-Oriented C++语言：**这部分也就是`C with Classes`所诉求的：包括构造函数和析构函数,封装、继承、多态、`virtual`函数……等等。这一部分是面向对象设计之古典守则在`C++`上的最直接实施。
3. **Template C++语言：**这是`C++`的泛型编程部分，也是大多数程序员经验最少的部分。由于`templates`威力强大，它们带来崭新的编程范型,也就是所谓的`template metaprogramming`(`TMP`,模板元编程)
4. **STL语言：**`STL`是个`template`程序库，看名称也知道，但它是非常特殊的一个。它对容器、迭代器、算法以及函数对象的规约有极佳的紧密配合与协调，然而`templates`及程序库也可以其他想法建置出来

## 条款2：尽量以`const`,`enum`,`inline`替换`#define`

由于宏会在预处理阶段进行处理，而不是编译阶段。可能会造成一些令人疑惑的问题。

* **符号表的混乱**

    例如定义如下宏：

    ```c
    #define ASPECT_RATIO 1.653
    ```

    符号名称`ASPECT_RATIO`也许从未被编译器看见；也许在编译器开始处理源码之前它就被预处理器移走了。于是记号名称`ASPECT_RATIO`有可能没进入符号表`symbol table`内。于是当你运用此常量但获得一个编译错误信息时，可能会带来困惑，因为这个错误信息也许会提到`1.653`而不是`ASPECT_RATIO`。如果`ASPECT_RATIO`被定义在一个非你所写的头文件内，你肯定对`1.653`以及它来自何处毫无概念，于是你将因为追踪它而浪费时间

    可以通过使用`const`来避免这种情况

    ```c
    const double AspectRatio =1.653; //大写名称通常用于宏，//因此这里改变名称写法。
    ```

* **可读性差**

    大量的互相嵌套的宏定义会造成代码的可读性极差

* **宏魔法**

    虽然宏只是一种在预处理阶段处理的文本替换，但仍然可以通过一些编译器特性，使**宏也具备图灵完备**

## 参考文档

> 《EffectiveC++中文版（第三版）》        [美]Scott Meyers 著        侯捷 译    电子工业出版社
