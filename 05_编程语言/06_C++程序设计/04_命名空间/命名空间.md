# C++ 命名空间

> 参考文档：
>
> [命名空间 (C++) | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/cpp/namespaces-cpp?view=msvc-170)
>
> 《C++ Primer》第五版 第十八章



## 概述

在 `C++` 中，**命名空间（namespace）** 是一种将全局作用域划分为不同逻辑部分的机制。它的主要目的是**防止命名冲突**。如果一个项目包含了多个不同的库时，两个库中有一个名称相同的函数`foo()`编译器无法区分到底要用哪一个函数就会出错。传统的解决方法是将这些全局的接口名称设定的很长来避免冲突的问题，命名空间通过为标识符（如变量、函数、类等）创建一个额外的“姓氏”来解决这个问题

**主要特点**

* **避免命名冲突**：这是命名空间最核心的功能。通过将代码放入不同的命名空间，即使它们有相同的名称，也可以共存

* **代码组织**：可以将相关的代码（例如一个库或模块的所有功能）组织在同一个命名空间下，使代码结构更清晰、更易于管理



## 命名空间的定义

命名空间之外的标识符可通过使用每个标识符的完全限定名（例如 `std::vector<std::string> vec;`）来访问成员，也可通过单个标识符的 `using` 声明 (`using std::string`) 或命名空间中所有标识符的 `using` 指令 (`using namespace std;`) 来访问成员。 头文件中的代码应始终使用完全限定的命名空间名称

一个命名空间定义应该包含两个部分，首先是关键字`namespace`,随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间：

```cpp
namespace cplusplus_primer {
    class Sales_data {/*.....*/};
    Sales_data operator+(const Sales_data&,
                        const Sales_data&);
    class Query {/*.......*/};
    class Query_base {/*.......*/};
}
```

上面的代码定义了一个名为`cplusplus_primer`的命名空间，该命名空间包含四个成员：三个类和一个重载的`+`运算符

**每个命名空间都是一个作用域**，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部

定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。**位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间**



## 命名空间可以是不连续的

和其他作用域不同的是，命名空间可以定义在几个不同的部分，例如：

```cpp
namespace nsp {
	//相关声明
}
```

如果之前没有名为`nsp`的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间定义并为其添加一些新成员的声明

命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：

* 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中
* 命名空间成员的定义部分则置于另外的源文件中

对于一些特殊的只能定义一次的实体：比如内联函数、静态数据成员、变量等命名命名空间中定义的名字也要满足这一要求



## 定义命名空间成员

如果作用域中存在合适的声明语句，则命名空间中的代码在使用同一命名空间定义的名字时就可以使用简写的形式

```cpp
namespace cplusplus_primer { // 重新打开命名空间cplusplus_primer
    // 命名空间中定义的成员可以直接使用名字，此时无须前缀
    std::istream& operator>>(std::istream& is, Sales_data& item) {/*....*/}
}
```

在命名空间`cpluap1uaprimer`内部,可以直接使用该命名空间的其他成员,比如在上面的代码中,可以直接使用`Sa1e_dsta`定义两数的形参。

尽管命名空间的成员可以定义在命名空间外部,但是这样的定义必须出现在所属命名空间的外层空间中。换句话说,可以在`cpluaplua_primer`或全局作用域中定义 `Sa1es_dataoperator+`,但是不能在一个不相关的作用域中定义这个运算符



## 全局命名空间

全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在全局命名空间中,全局命名空间以隐式的方式声明,并且在所有程序中都存在

下面的形式

```cpp
::imember_name
```

表示全局命名空间中的一个成员

**特点：**

* **默认位置**：任何未在自定义命名空间、类或函数内部声明的标识符（变量、函数、类名等）都位于全局命名空间中
* **无名**：它没有名称。当你直接定义一个函数或变量时，它就在这个空间里
* **访问方式**：要从其他命名空间内部显式地访问全局命名空间的成员，可以使用**作用域解析运算符 `::`**，且其前方不加任何名称。例如 `::imember_name`



## 嵌套的命名空间

嵌套的命名空间是指定义在其他命名空间中的命名空间:

```cpp
// 嵌套的命名空间是指定义在其他命名空间之中的命名空间
namespace cplusplus_primer {
    // 第一个嵌套的命名空间:定义了库的query部分
    namespace Querylib {
        class Query {/*....*/};
        Query operators(const Query&, const Query&);
    }

    // 第二个嵌套的命名空间:定义了库的sales_data部分
    namespace Bookstore {
        class Quote {/*....*/};
        class Disc_quote : public Quote {/*....*/};
        // ...其他类和函数的定义
    }
}
```

上面的代码将命名空间`cplusplus_primer`分制为两个嵌套的命名空间,分别是`QueryLib`和`Bookstore`

嵌套的命名空间同时是一个联套的作用域,它嵌套在外层面名空间的作用域中,嵌套的命名空间中的名字遵循的规则与往常类似，内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效,外层命名空间中的代码要想访间它必须在名字前添加限定符。例如,在嵌套的命名空间`QueryLib`中声明的类名是`cplusplus_Primer::QueryLib::Query`



## 内联命名空间

`C++11`新标准引入了一种新的嵌套命名空间，称为**内联命名空间(inline namespace)**。和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。也就是说，我们无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它

定义内联命名空间的方式是在关键字`namespace`前添加关键字`inline`

```cpp
inline namespace FifthEd {
    // 该命名空间表示《C++ Primer》第5版的代码
}

namespace FifthEd { //隐式内联
     class Query_base{ /*.…*/ };
     // 其他与Query有关的声明
}
```

关键字`inline`必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写`inline`,也可以不写

`C++`中的**内联命名空间 (`inline namespace`)** 是`C++11`引入的一个特性，其主要作用是**版本控制**和**简化命名空间访问**

### 作用

一个 `inline namespace` 的核心作用是：**该命名空间内的所有成员（变量、函数、类等）都会被视作其父命名空间的成员**

这意味着，当你在代码中引用时，可以省略这个内联命名空间的名称，编译器会自动在其中查找

### 主要使用场景

最经典和主要的使用场景是**库的版本管理**，它允许库的作者在不破坏现有用户代码（`API/ABI` 兼容性）的情况下，平滑地升级库。前提是在最初的版本中就使用了`inline namespace`并且在调用时不去指定版本

#### 场景：库版本升级

假设你是一个库的开发者，你的库 `MyLib` 有一个版本 `v1`

```cpp
namespace MyLib {
    namespace v1 {
        void myFunction() { /* ... 旧的实现 ... */ }
    }

    // 为了方便，导出 v1 的成员
    using namespace v1;
}
```

后来，你开发了 `v2` 版本，其中 `myFunction` 有了新的、不兼容的实现。你希望新用户默认使用 `v2`，但老用户如果需要，仍然可以继续使用 `v1`。这时 `inline namespace` 就派上用场了

```cpp
namespace MyLib {
    namespace v1 { // 旧版本，不再是内联
        void myFunction() { /*...旧的实现...*/ }
    }

    inline namespace v2 { // 新版本，设为内联
        void myFunction() { /*...新的更好的实现...*/ }
    }
}
```

**这对用户意味着什么？**

1. **无缝升级**：对于用户代码，他们不需要做任何修改。调用 `MyLib::myFunction()` 会自动解析到 `MyLib::v2::myFunction()`，因为 `v2` 是 `inline` 的

    ```cpp
    // filepath: user_code.cpp
    #include "mylib.h"
    void useLib() {
        // 自动调用 MyLib::v2::myFunction()
        MyLib::myFunction();
    }
    ```

2. **向后兼容**：如果某个用户由于特殊原因必须使用旧版本，他们仍然可以通过显式指定版本号来访问

    ```cpp
    // filepath: legacy_user_code.cpp
    #include "mylib.h"
    void useOldVersion() {
        // 显式调用旧版本
        MyLib::v1::myFunction();
    }
    ```

### 总结

- **核心功能**：将命名空间成员“提升”到父命名空间，使其可以直接访问
- **主要用途**：实现库的平滑版本过渡。开发者可以发布新版本的实现，并将其设为 `inline`，使其成为默认版本，而旧版本依然可以通过全限定名访问，从而保持了向后兼容性
- **其他用途**：在某些复杂嵌套的命名空间结构中，可以用来将某个深层命名空间中的常用功能“导出”到上层，简化调用



## 未命名的命名空间

未命名的命名空间(`unnamed namespace`)是指关键字`namespace`后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期，它们在第一次使用前创建，并且直到程序结束才销毁

一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。**每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。**在这**两个未命名的命名空间中可以定义相同的名字**，并且这些定义表示的是不同实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体

### 引入未命名的命名空间目的

`C++`标准引入未命名的命名空间是为了替代`static`关键字，在文件中进行静态声明的做法是从`C`语言继承而来，现在在文件中进行静态声明的做法已经被`C++`标准取消了,现在的做法是使用未命名的命名空间

### 未命名的命名空间成员的使用

使用时**不需要添加任何命名空间前缀**，直接调用即可

```cpp
#include <iostream>

// 定义一个未命名命名空间
namespace {
    // 在此命名空间内定义一个变量和一个函数
    int private_variable = 100;

    void private_function() {
        std::cout << "Called a function from the unnamed namespace." << std::endl;
        std::cout << "The private variable's value is: " << private_variable << std::endl;
    }
} // 未命名命名空间结束

int main() {
    // 1. 直接访问未命名命名空间中的变量
    std::cout << "Accessing private_variable directly: " << private_variable << std::endl;

    // 2. 直接调用未命名命名空间中的函数
    private_function();

    // 修改变量的值
    private_variable = 200;
    std::cout << "After modification, private_variable is: " << private_variable << std::endl;

    return 0;
}
```



## 使用命名空间

如果命名空间的名称非常长的时候当我们要使用其中的成员时就很繁琐，我们可以使用其他方法

### 命名空间的别名

命名空间的别名(`namespace alias`)使得我们可以为命名空间的名字设定一个短得多的同义词。命名空间的别名声明以关键字`namespace`开始，后面是别名所用的名字、`=`符号、命名空间原来的名字以及一个分号。例如，一个很长的命名空间的名字形如

```cpp
namespace cplusplus_primer {/*..*/};
```

我们可以为其设定一个短得多的同义词：

```cpp
namespace primer = cplusplus_primer;
```

命名空间的别名也可以指向一个嵌套的命名空间：

```cpp
namespace Qlib=cplusplus_primer::QueryLib;
Qlib::Query q;
```

同时一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价

### using声明

一条`using`声明语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字，例如：

```cpp
using std::cout;  
using std::vector;  
```

`using`声明引入的名字遵守与过去一样的作用域规则：它的有效范围从`using`声明的地方开始，一直到`using`声明所在的作用域结束为止。一条`using`声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中，在类的作用域中，这样的声明语句只能指向基类成员

### using指示

`using`指示和`using`声明类似的地方是，我们可以使用命名空间名字的简写形式；和`using`声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。
`using`指示以关键字`using`开始，后面是关键字`namespace`以及命名空间的名字，例如：

```cpp
using namespace std;
```

如果这里所用的名字不是一个已经定义好的命名空间的名字，否则程序将发生错误。`using`指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中
`using`指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从`using`指示开始，一直到`using`指示所在的作用域结束都能使用

### 头文件与using声明或指示

头文件如果在其顶层作用域中含有`using`指示或`using`声明，则会将名字注入到所有包含了该头文件的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用`using`指示或`using`声明

