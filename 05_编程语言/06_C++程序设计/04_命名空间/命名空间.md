# C++ 命名空间

> 参考文档：
>
> [命名空间 (C++) | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/cpp/namespaces-cpp?view=msvc-170)
>
> 《C++_Primer》第五版



## 概述

在 `C++` 中，**命名空间（namespace）** 是一种将全局作用域划分为不同逻辑部分的机制。它的主要目的是**防止命名冲突**。如果一个项目包含了多个不同的库时，两个库中有一个名称相同的函数`foo()`编译器无法区分到底要用哪一个函数就会出错。传统的解决方法是将这些全局的接口名称设定的很长来避免冲突的问题，命名空间通过为标识符（如变量、函数、类等）创建一个额外的“姓氏”来解决这个问题

**主要特点**

* **避免命名冲突**：这是命名空间最核心的功能。通过将代码放入不同的命名空间，即使它们有相同的名称，也可以共存

* **代码组织**：可以将相关的代码（例如一个库或模块的所有功能）组织在同一个命名空间下，使代码结构更清晰、更易于管理



## 命名空间的定义

命名空间之外的标识符可通过使用每个标识符的完全限定名（例如 `std::vector<std::string> vec;`）来访问成员，也可通过单个标识符的 `using` 声明 (`using std::string`) 或命名空间中所有标识符的 `using` 指令 (`using namespace std;`) 来访问成员。 头文件中的代码应始终使用完全限定的命名空间名称

一个命名空间定义应该包含两个部分，首先是关键字`namespace`,随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量(及其初始化操作)、函数(及其定义)、模板和其他命名空间：

```cpp
namespace cplusplus_primer {
    class Sales_data {/*.....*/};
    Sales_data operator+(const Sales_data&,
                        const Sales_data&);
    class Query {/*.......*/};
    class Query_base {/*.......*/};
}
```

上面的代码定义了一个名为`cplusplus_primer`的命名空间，该命名空间包含四个成员：三个类和一个重载的`+`运算符

**每个命名空间都是一个作用域**，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部

定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。**位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间**



## 命名空间可以是不连续的

和其他作用域不同的是，命名空间可以定义在几个不同的部分，例如：

```cpp
namespace nsp {
	//相关声明
}
```

如果之前没有名为`nsp`的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间定义并为其添加一些新成员的声明

命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：

* 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中
* 命名空间成员的定义部分则置于另外的源文件中

对于一些特殊的只能定义一次的实体：比如内联函数、静态数据成员、变量等命名命名空间中定义的名字也要满足这一要求



## 定义命名空间成员

如果作用域中存在合适的声明语句，则命名空间中的代码在使用同一命名空间定义的名字时就可以使用简写的形式

```cpp
namespace cplusplus_primer { // 重新打开命名空间cplusplus_primer
    // 命名空间中定义的成员可以直接使用名字，此时无须前缀
    std::istream& operator>>(std::istream& is, Sales_data& item) {/*....*/}
}
```

在命名空间`cpluap1uaprimer`内部,可以直接使用该命名空间的其他成员,比如在上面的代码中,可以直接使用`Sa1e_dsta`定义两数的形参。

尽管命名空间的成员可以定义在命名空间外部,但是这样的定义必须出现在所属命名空间的外层空间中。换句话说,可以在`cpluaplua_primer`或全局作用域中定义 `Sa1es_dataoperator+`,但是不能在一个不相关的作用域中定义这个运算符



## 全局命名空间

全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在全局命名空间中,全局命名空间以隐式的方式声明,并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。作用城运算符同样可以用于全局作用域的成员

下面的形式

```cpp
::imember_name
```

表示全局命名空间中的一个成员

**特点：**

* **默认位置**：任何未在自定义命名空间、类或函数内部声明的标识符（变量、函数、类名等）都位于全局命名空间中
* **无名**：它没有名称。当你直接定义一个函数或变量时，它就在这个空间里
* **访问方式**：要从其他命名空间内部显式地访问全局命名空间的成员，可以使用**作用域解析运算符 `::`**，且其前方不加任何名称。例如 `::imember_name`

## 嵌套的命名空间

## 内联命名空间