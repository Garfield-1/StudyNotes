# 设计模式

[TOC]

## 概述

这些模式根据目的和关注点的不同，通常被分为三大类：**创建型（Creational）**、**结构型（Structural）** 和**行为型（Behavioral）**

## 创建型模式 (Creational Patterns)

这类模式专注于**对象的创建过程**，将对象的实例化过程抽象化，有助于系统独立于其对象的创建、组合和表示方式

| 模式名称                            | 核心思想                                                     |
| :---------------------------------- | :----------------------------------------------------------- |
| **单例模式 (Singleton)**            | 确保一个类只有一个实例，并提供一个全局访问点                 |
| **工厂方法模式 (Factory Method)**   | 定义一个用于创建对象的接口，让子类决定实例化哪一个类         |
| **抽象工厂模式 (Abstract Factory)** | 提供一个接口，用于创建一系列相关或相互依赖的对象的家族，而无需指定它们具体的类 |
| **建造者模式 (Builder)**            | 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示 |
| **原型模式 (Prototype)**            | 通过复制现有实例来创建新对象，而不是使用传统的构造函数       |

## 结构型模式 (Structural Patterns)

这类模式关注**类和对象的组合**，用于创建更大的结构，通常涉及类之间的继承或组合关系

| 模式名称                  | 核心思想                                                     |
| :------------------------ | :----------------------------------------------------------- |
| **适配器模式(Adapter)**   | 将一个类的接口转换成客户希望的另一个接口，使原本不兼容的类可以协同工作 |
| **桥接模式 (Bridge)**     | 将抽象部分与实现部分分离，使它们都可以独立地变化             |
| **组合模式 (Composite)**  | 将对象组合成树形结构以表示“部分-整体”的层次结构，使客户端对单个对象和组合对象的使用具有一致性 |
| **装饰器模式(Decorator)** | 动态地给一个对象添加一些额外的职责或功能                     |
| **外观模式 (Facade)**     | 为子系统提供一个统一的、简化的接口，使子系统更容易使用       |
| **享元模式 (Flyweight)**  | 运用共享技术有效地支持大量细粒度的对象，以减少内存消耗       |
| **代理模式 (Proxy)**      | 为另一个对象提供一个替身或占位符，以控制对这个对象的访问     |

## 行为型模式 (Behavioral Patterns)

这类模式关注**对象之间的职责分配和通信方式**，描述对象和类如何协作共同完成一个任务，以及它们如何交互

| 模式名称                                 | 核心思想                                                     |
| :--------------------------------------- | :----------------------------------------------------------- |
| **模板方法模式 (Template Method)**       | 定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现       |
| **策略模式 (Strategy)**                  | 定义一系列算法，并将每一个算法封装起来，使它们可以相互替换   |
| **观察者模式 (Observer)**                | 定义对象之间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会自动收到通知 |
| **迭代器模式 (Iterator)**                | 提供一种方法顺序访问聚合对象（如列表、数组）中的各个元素，而不需要暴露该对象的内部表示 |
| **责任链模式 (Chain of Responsibility)** | 使多个对象都有机会处理请求，从而避免请求发送者和接收者之间的耦合关系 |
| **命令模式 (Command)**                   | 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作 |
| **备忘录模式 (Memento)**                 | 在不破坏对象封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 |
| **状态模式 (State)**                     | 允许一个对象在其内部状态改变时改变它的行为，对象看起来好像修改了它的类 |
| **调停者模式 (Mediator)**                | 定义一个封装一系列对象如何交互的中心对象，减少对象之间的直接耦合 |
| **访问者模式 (Visitor)**                 | 表示一个作用于某对象结构中的各元素的操作。它可以在不改变各元素的类的前提下定义作用于这些元素的新操作 |
| **解释器模式 (Interpreter)**             | 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子 |